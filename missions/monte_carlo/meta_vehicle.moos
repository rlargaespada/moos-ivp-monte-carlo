//*******************************************************
// ShoreSide Configuration File

ServerHost = $(IP_ADDR)
ServerPort = $(V_MOOSDB)
Community  = $(VNAME)

#include plug_origin_warp.moos

//------------------------------------------------------------
Processconfig = ANTLER
{
  MSBetweenLaunches = 50

  Run = MOOSDB           @ NewConsole = false
  Run = pRealm           @ NewConsole = false
  Run = pHelmIvP         @ NewConsole = false

  // Run = pLogger          @ NewConsole = false
//   Run = uProcessWatch    @ NewConsole = false
//   Run = uLoadWatch       @ NewConsole = false

  Run = uSimMarineV22    @ NewConsole = false
  Run = pMarinePIDV22    @ NewConsole = false
  Run = pNodeReporter    @ NewConsole = false
#ifdef DRIFT_DIR random
  Run = uTimerScript     @ NewConsole = false ~ uTimerScript_RANDOM_DRIFTS
#endif

  Run = pShare           @ NewConsole = false
  Run = pHostInfo        @ NewConsole = false
  Run = uFldNodeBroker   @ NewConsole = false

  Run = pObstacleMgr     @ NewConsole = false

  Run = uTimerScript     @ NewConsole = false ~ uTimerScript_PLANNER_PLACEHOLDER_A
  Run = uTimerScript     @ NewConsole = false ~ uTimerScript_PLANNER_PLACEHOLDER_B
}


//----------------------------------------------------
// pHelmIvP Configuration Block

ProcessConfig = pHelmIvP
{
  AppTick    = 4
  CommsTick  = 4

  behaviors    = targ_$(VNAME).bhv
  verbose      = false
  domain       = course:0:359:360
  domain       = speed:0:4:41
}


// todo: determine which variables to log for pLogger
// todo uProcessWatch: determine which vehicle apps to watch, where to write failures. add to NodeBroker
// todo: determine thresholds for uLoadWatch


//------------------------------------------
// uSimMarineV22 config block

ProcessConfig = uSimMarineV22
{
  AppTick  	= 4
  CommsTick	= 4

  prefix = NAV

  // start pose
  start_pos = $(START_POS)  // x, y
  start_heading = 35  // depends on map/layout
  // start_speed = 0
  // start_depth = 0

  // drift config
#ifdef DRIFT_DIR x
  drift_x = $(DRIFT_STRENGTH)
  drift_y = 0
#elseifdef DRIFT_DIR y
  drift_x = 0
  drift_y = $(DRIFT_STRENGTH)
#endif
  rotate_speed = 0  //? maybe in the future

  // keep default turn speed, acceleration parameters
  // depth and buoyancy rate unused
  // no wind conditions

  turn_rate = 40
  thrust_map = 0:0, 20:1, 40:2, 60:3, 80:4, 100:5

  // post_des_thrust      = DESIRED_THRUSTX
  // post_des_rudder      = DESIRED_RUDDERX

  // // BELOW are embedded PID controller config params
  // depth_control = false

  // // Yaw PID controller
  // yaw_pid_kp             = 1,2
  // yaw_pid_kd             = 0.0
  // yaw_pid_ki             = 0.3
  // yaw_pid_integral_limit = 0.07

  // // Speed PID controller
  // speed_pid_kp           = 1.0
  // speed_pid_kd           = 0.0
  // speed_pid_ki           = 0.0
  // speed_pid_integral_limit = 0.07

  // // Maximums
  // maxrudder  = 100
  // maxthrust  = 100

  // // A non-zero SPEED_FACTOR overrides use of SPEED_PID
  // // Will set DESIRED_THRUST = DESIRED_SPEED * SPEED_FACTOR
  // speed_factor = 20

  // NOTE: using sim resets instead of wormholes
  // add wormhole from goal back to start
  // wormhole = tag=next_trial, madrid_poly={format=radial, x=$(GOAL_X), y=$(GOAL_Y), radius=8, pts=6}
  // wormhole = tag=next_trial, weber_poly={format=radial, x=$(START_X), y=$(START_Y), radius=8, pts=6}
  // wormhole = tag=next_trial, connection=from_madrid

}


//------------------------------------------
// pMarinePIDV22 config block
ProcessConfig = pMarinePIDV22
{
  AppTick    = 20
  CommsTick  = 20

  verbose       = true
  depth_control = false
  active_start  = true

  // Yaw PID controller
  yaw_pid_kp             = 1.2
  yaw_pid_kd             = 0.0
  yaw_pid_ki             = 0.3
  yaw_pid_integral_limit = 0.07

  // Speed PID controller
  speed_pid_kp           = 1.0
  speed_pid_kd           = 0.0
  speed_pid_ki           = 0.0
  speed_pid_integral_limit = 0.07

  // Maximums
  maxrudder  = 100
  maxthrust  = 100

  // A non-zero SPEED_FACTOR overrides use of SPEED_PID
  // Will set DESIRED_THRUST = DESIRED_SPEED * SPEED_FACTOR
  speed_factor = 20
}


//------------------------------------------
// pNodeReporter config block

ProcessConfig = pNodeReporter
{
  AppTick    = 2
  CommsTick	 = 2

  platform_type = kayak
  platform_color = $(VCOLOR)
}


//------------------------------------------
// uTimerScript_RANDOM_DRIFTS configuration  block
// simulates random drift vectors on vehicle

ProcessConfig = uTimerScript_RANDOM_DRIFTS
{
  AppTick   = 2
  CommsTick = 2
  paused        = false
  reset_max     = unlimited
  reset_time    = end
  delay_reset   = 10
  time_warp     = 0.25:2.0
  script_name   = RANDOM_DRIFTS
  script_atomic = true

  randvar = varname=ANG, min=0,   max=359, key=at_reset
  randvar = varname=MAG, min=0.5, max=2, key=at_reset

  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*0.2}", time=0
  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*0.2}", time=2
  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*0.2}", time=4
  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*0.2}", time=6
  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*0.2}", time=8
  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*-0.2}", time=10
  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*-0.2}", time=12
  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*-0.2}", time=14
  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*-0.2}", time=16
  event = var=DRIFT_VECTOR_ADD, val="$[ANG],{$[MAG]*-0.2}", Time=18
}


#include plug_pShare.moos
#include plug_pHostInfo.moos
#include plug_uFldNodeBroker.moos
#include plug_pObstacleMgr.moos

//------------------------------------------
// uTimerScript_PLANNER_PLACEHOLDER configuration  block
// While planner isn't written, emulate planner postings through timerscripts
ProcessConfig = uTimerScript_PLANNER_PLACEHOLDER_A
{
  AppTick   = 2
  CommsTick = 2
  paused        = false
  reset_max     = unlimited
  reset_time    = end
  delay_reset   = 0
  script_name   = PLANNER_PLACEHOLDER_A
  script_atomic = true
  condition = $(PATH_REQUEST_VAR) != none
  upon_awake = restart

  event = var=$(PATH_REQUEST_VAR), val=none  // clear request

  // go into planning mode, move towards start
  event = var=$(PATH_COMPLETE_VAR), val=false
  event = var=$(PATH_FOUND_VAR), val=false
  event = var=STATION_UPDATES, val="station_pt = $(START_POS)"

  // after "planning" time, go into traversal mode with found points
  event = var=$(PATH_FOUND_VAR), val=true, time=10
  event = var=PATH_UPDATE, val="points = $(START_POS):$(GOAL_POS)"

  // encountered an obstacle, go back into planning mode
  event = var=$(PATH_FOUND_VAR), val=false, time=60:70
  event = var=STATION_UPDATES, val="center_activate = true"

  // found new path, go back into traversal mode
  event = var=$(PATH_FOUND_VAR), val=true, time=80:100
  event = var=PATH_UPDATE, val="points = $(START_POS):$(GOAL_POS)"
}

ProcessConfig = uTimerScript_PLANNER_PLACEHOLDER_B
{
  AppTick   = 2
  CommsTick = 2
  paused        = false
  reset_max     = unlimited
  reset_time    = end
  delay_reset   = 0
  script_name   = PLANNER_PLACEHOLDER_B
  script_atomic = true
  condition = WAYPOINTS_COMPLETE == true

  // waypoints are done, let uEvalPath know
  event = var=$(PATH_COMPLETE_VAR), val=true
  event = var=WAYPOINTS_COMPLETE, val=false
}
